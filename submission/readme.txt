Design Decisions
Our code generator mostly follows the conventions of the reference compiler, generating vtables and initializers similarly, and using slightly modified assembly for the built-in functions. 
The code generator begins by generating a control flow graph with three address codes in each block. The number of temporaries necessary and the three address codes are generated by traversing the AST for the method and subtracting from the stack pointer by that number times 16 so that the stack is 16-byte aligned. Each method then converts the CFG/TAC IR directly into assembly, functioning similarly to a stack machine. Temporaries are stored in the stack as they are calculated, where they are popped off the top of the stack when they are used in an expression. Method dispatches use the stack to push arguments and return values. 

Let expressions are also stored on the stack as temporaries when entering the method body and code to initialize them is emitted if applicable. Their relative location on the stack is stored within a hashtable for use within the duration of the let functions body, and then removed from the hashtable and code is emitted to remove them from the stack. 

New allocates a new object, and sets all of its internal information (class tag, name, size, attributes, method table) on allocation and returns a pointer. Attributes are first added to the object with code emitted for default initializations. They are then initialized if needed by creating a mini-CFG for the attribute initializer, and emitting code to execute and store it, then storing the result. If there is no initialization, the previously set default initialization is unmodified. 

For case expressions, we get all of the classes in the program and build an inheritance tree for those classes. Then starting from Object and going down through each child using depth first search, we check if that class has a matching branch in the case statement, and if so save that branch label in a hash table with the class as the key. This branch label is then also passed to the child elements and is used if a child class doesnâ€™t have a matching branch. If a class has no matching branches and is used as the runtime class for the case statement, then a runtime error is generated saying that no matching branch was found. If the object is void then a runtime error is also generated.

Dispatch is handled similarly for all cases, with the only distinction between each being the caller. Code to evaluate the arguments in order is emitted and any side effects are stored. Arguments are pushed onto the stack, and the function is called. After the function call, the result is in register r13. The stack pointer is incremented to remove the arguments and the result is stored on top of the stack. Dynamic and static dispatches have additional void checks to prevent dispatch on void. 

test1.cl - This test case was chosen because it tests (almost) every single unary and binary operator in the COOL language. The only operation excluded was division because it was causing frequent division by zero errors. We found this test case very helpful for diagnosing hard to find issues with arithmetic and logical operators. 

test2.cl - This test case was chosen because it let us test aliasing and making sure our environment was working properly.

test3.cl - This test case was chosen because it was a difficult feature to get fully working, and stress tested case expressions. 

test4.cl - This test case was chosen because it tested aliasing and side effects from functions extensively. 
